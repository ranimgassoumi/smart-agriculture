import type { Document } from '../bson';
<<<<<<< HEAD
import type { ExplainVerbosityLike } from '../explain';
import type { MongoClient } from '../mongo_client';
import { AggregateOperation, type AggregateOptions } from '../operations/aggregate';
import { executeOperation, type ExecutionResult } from '../operations/execute_operation';
import type { ClientSession } from '../sessions';
import type { Sort } from '../sort';
import type { Callback, MongoDBNamespace } from '../utils';
import { mergeOptions } from '../utils';
import type { AbstractCursorOptions } from './abstract_cursor';
import { AbstractCursor, assertUninitialized } from './abstract_cursor';
=======
import { MongoAPIError } from '../error';
import {
  Explain,
  type ExplainCommandOptions,
  type ExplainVerbosityLike,
  validateExplainTimeoutOptions
} from '../explain';
import type { MongoClient } from '../mongo_client';
import { type Abortable } from '../mongo_types';
import { AggregateOperation, type AggregateOptions } from '../operations/aggregate';
import { executeOperation } from '../operations/execute_operation';
import type { ClientSession } from '../sessions';
import type { Sort } from '../sort';
import { mergeOptions, type MongoDBNamespace } from '../utils';
import {
  type AbstractCursorOptions,
  CursorTimeoutMode,
  type InitialCursorResponse
} from './abstract_cursor';
import { ExplainableCursor } from './explainable_cursor';
>>>>>>> khawla-part

/** @public */
export interface AggregationCursorOptions extends AbstractCursorOptions, AggregateOptions {}

<<<<<<< HEAD
/** @internal */
const kPipeline = Symbol('pipeline');
/** @internal */
const kOptions = Symbol('options');

=======
>>>>>>> khawla-part
/**
 * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB
 * allowing for iteration over the results returned from the underlying query. It supports
 * one by one document iteration, conversion to an array or can be iterated as a Node 4.X
 * or higher stream
 * @public
 */
<<<<<<< HEAD
export class AggregationCursor<TSchema = any> extends AbstractCursor<TSchema> {
  /** @internal */
  [kPipeline]: Document[];
  /** @internal */
  [kOptions]: AggregateOptions;
=======
export class AggregationCursor<TSchema = any> extends ExplainableCursor<TSchema> {
  public readonly pipeline: Document[];
  /** @internal */
  private aggregateOptions: AggregateOptions & Abortable;
>>>>>>> khawla-part

  /** @internal */
  constructor(
    client: MongoClient,
    namespace: MongoDBNamespace,
    pipeline: Document[] = [],
<<<<<<< HEAD
    options: AggregateOptions = {}
  ) {
    super(client, namespace, options);

    this[kPipeline] = pipeline;
    this[kOptions] = options;
  }

  get pipeline(): Document[] {
    return this[kPipeline];
  }

  clone(): AggregationCursor<TSchema> {
    const clonedOptions = mergeOptions({}, this[kOptions]);
    delete clonedOptions.session;
    return new AggregationCursor(this.client, this.namespace, this[kPipeline], {
=======
    options: AggregateOptions & Abortable = {}
  ) {
    super(client, namespace, options);

    this.pipeline = pipeline;
    this.aggregateOptions = options;

    const lastStage: Document | undefined = this.pipeline[this.pipeline.length - 1];

    if (
      this.cursorOptions.timeoutMS != null &&
      this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION &&
      (lastStage?.$merge != null || lastStage?.$out != null)
    )
      throw new MongoAPIError('Cannot use $out or $merge stage with ITERATION timeoutMode');
  }

  clone(): AggregationCursor<TSchema> {
    const clonedOptions = mergeOptions({}, this.aggregateOptions);
    delete clonedOptions.session;
    return new AggregationCursor(this.client, this.namespace, this.pipeline, {
>>>>>>> khawla-part
      ...clonedOptions
    });
  }

  override map<T>(transform: (doc: TSchema) => T): AggregationCursor<T> {
    return super.map(transform) as AggregationCursor<T>;
  }

  /** @internal */
<<<<<<< HEAD
  _initialize(session: ClientSession, callback: Callback<ExecutionResult>): void {
    const aggregateOperation = new AggregateOperation(this.namespace, this[kPipeline], {
      ...this[kOptions],
      ...this.cursorOptions,
      session
    });

    executeOperation(this.client, aggregateOperation, (err, response) => {
      if (err || response == null) return callback(err);

      // TODO: NODE-2882
      callback(undefined, { server: aggregateOperation.server, session, response });
    });
  }

  /** Execute the explain for the cursor */
  async explain(verbosity?: ExplainVerbosityLike): Promise<Document> {
    return executeOperation(
      this.client,
      new AggregateOperation(this.namespace, this[kPipeline], {
        ...this[kOptions], // NOTE: order matters here, we may need to refine this
        ...this.cursorOptions,
        explain: verbosity ?? true
      })
    );
=======
  async _initialize(session: ClientSession): Promise<InitialCursorResponse> {
    const options = {
      ...this.aggregateOptions,
      ...this.cursorOptions,
      session,
      signal: this.signal
    };
    if (options.explain) {
      try {
        validateExplainTimeoutOptions(options, Explain.fromOptions(options));
      } catch {
        throw new MongoAPIError(
          'timeoutMS cannot be used with explain when explain is specified in aggregateOptions'
        );
      }
    }

    const aggregateOperation = new AggregateOperation(this.namespace, this.pipeline, options);

    const response = await executeOperation(this.client, aggregateOperation, this.timeoutContext);

    return { server: aggregateOperation.server, session, response };
  }

  /** Execute the explain for the cursor */
  async explain(): Promise<Document>;
  async explain(verbosity: ExplainVerbosityLike | ExplainCommandOptions): Promise<Document>;
  async explain(options: { timeoutMS?: number }): Promise<Document>;
  async explain(
    verbosity: ExplainVerbosityLike | ExplainCommandOptions,
    options: { timeoutMS?: number }
  ): Promise<Document>;
  async explain(
    verbosity?: ExplainVerbosityLike | ExplainCommandOptions | { timeoutMS?: number },
    options?: { timeoutMS?: number }
  ): Promise<Document> {
    const { explain, timeout } = this.resolveExplainTimeoutOptions(verbosity, options);
    return (
      await executeOperation(
        this.client,
        new AggregateOperation(this.namespace, this.pipeline, {
          ...this.aggregateOptions, // NOTE: order matters here, we may need to refine this
          ...this.cursorOptions,
          ...timeout,
          explain: explain ?? true
        })
      )
    ).shift(this.deserializationOptions);
  }

  /** Add a stage to the aggregation pipeline
   * @example
   * ```
   * const documents = await users.aggregate().addStage({ $match: { name: /Mike/ } }).toArray();
   * ```
   * @example
   * ```
   * const documents = await users.aggregate()
   *   .addStage<{ name: string }>({ $project: { name: true } })
   *   .toArray(); // type of documents is { name: string }[]
   * ```
   */
  addStage(stage: Document): this;
  addStage<T = Document>(stage: Document): AggregationCursor<T>;
  addStage<T = Document>(stage: Document): AggregationCursor<T> {
    this.throwIfInitialized();
    if (
      this.cursorOptions.timeoutMS != null &&
      this.cursorOptions.timeoutMode === CursorTimeoutMode.ITERATION &&
      (stage.$out != null || stage.$merge != null)
    ) {
      throw new MongoAPIError('Cannot use $out or $merge stage with ITERATION timeoutMode');
    }
    this.pipeline.push(stage);
    return this as unknown as AggregationCursor<T>;
>>>>>>> khawla-part
  }

  /** Add a group stage to the aggregation pipeline */
  group<T = TSchema>($group: Document): AggregationCursor<T>;
  group($group: Document): this {
<<<<<<< HEAD
    assertUninitialized(this);
    this[kPipeline].push({ $group });
    return this;
=======
    return this.addStage({ $group });
>>>>>>> khawla-part
  }

  /** Add a limit stage to the aggregation pipeline */
  limit($limit: number): this {
<<<<<<< HEAD
    assertUninitialized(this);
    this[kPipeline].push({ $limit });
    return this;
=======
    return this.addStage({ $limit });
>>>>>>> khawla-part
  }

  /** Add a match stage to the aggregation pipeline */
  match($match: Document): this {
<<<<<<< HEAD
    assertUninitialized(this);
    this[kPipeline].push({ $match });
    return this;
=======
    return this.addStage({ $match });
>>>>>>> khawla-part
  }

  /** Add an out stage to the aggregation pipeline */
  out($out: { db: string; coll: string } | string): this {
<<<<<<< HEAD
    assertUninitialized(this);
    this[kPipeline].push({ $out });
    return this;
=======
    return this.addStage({ $out });
>>>>>>> khawla-part
  }

  /**
   * Add a project stage to the aggregation pipeline
   *
   * @remarks
   * In order to strictly type this function you must provide an interface
   * that represents the effect of your projection on the result documents.
   *
   * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.
   * You should specify a parameterized type to have assertions on your final results.
   *
   * @example
   * ```typescript
   * // Best way
   * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });
   * // Flexible way
   * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });
   * ```
   *
   * @remarks
   * In order to strictly type this function you must provide an interface
   * that represents the effect of your projection on the result documents.
   *
   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,
   * it **does not** return a new instance of a cursor. This means when calling project,
   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.
   * Take note of the following example:
   *
   * @example
   * ```typescript
   * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);
   * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });
   * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();
   *
   * // or always use chaining and save the final cursor
   *
   * const cursor = coll.aggregate().project<{ a: string }>({
   *   _id: 0,
   *   a: { $convert: { input: '$a', to: 'string' }
   * }});
   * ```
   */
  project<T extends Document = Document>($project: Document): AggregationCursor<T> {
<<<<<<< HEAD
    assertUninitialized(this);
    this[kPipeline].push({ $project });
    return this as unknown as AggregationCursor<T>;
=======
    return this.addStage<T>({ $project });
>>>>>>> khawla-part
  }

  /** Add a lookup stage to the aggregation pipeline */
  lookup($lookup: Document): this {
<<<<<<< HEAD
    assertUninitialized(this);
    this[kPipeline].push({ $lookup });
    return this;
=======
    return this.addStage({ $lookup });
>>>>>>> khawla-part
  }

  /** Add a redact stage to the aggregation pipeline */
  redact($redact: Document): this {
<<<<<<< HEAD
    assertUninitialized(this);
    this[kPipeline].push({ $redact });
    return this;
=======
    return this.addStage({ $redact });
>>>>>>> khawla-part
  }

  /** Add a skip stage to the aggregation pipeline */
  skip($skip: number): this {
<<<<<<< HEAD
    assertUninitialized(this);
    this[kPipeline].push({ $skip });
    return this;
=======
    return this.addStage({ $skip });
>>>>>>> khawla-part
  }

  /** Add a sort stage to the aggregation pipeline */
  sort($sort: Sort): this {
<<<<<<< HEAD
    assertUninitialized(this);
    this[kPipeline].push({ $sort });
    return this;
=======
    return this.addStage({ $sort });
>>>>>>> khawla-part
  }

  /** Add a unwind stage to the aggregation pipeline */
  unwind($unwind: Document | string): this {
<<<<<<< HEAD
    assertUninitialized(this);
    this[kPipeline].push({ $unwind });
    return this;
=======
    return this.addStage({ $unwind });
>>>>>>> khawla-part
  }

  /** Add a geoNear stage to the aggregation pipeline */
  geoNear($geoNear: Document): this {
<<<<<<< HEAD
    assertUninitialized(this);
    this[kPipeline].push({ $geoNear });
    return this;
=======
    return this.addStage({ $geoNear });
>>>>>>> khawla-part
  }
}
